\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{svg}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{extarrows}
\usepackage[ruled,linesnumbered]{algorithm2e}

\lstdefinestyle{refactor} {
    keywordstyle=\ttfamily\color{green}\ttfamily,
    stringstyle=\sffamily\color{black},
    morekeywords={Seq,Pipe,Farm,Comp,Map},
}

\begin{document}	
\title{}

\maketitle

\section{Grammar and Parser}
The grammar defines basic constructs of patterns and it is used as an input to parser generator ANTLR(ANother Tool for Language Recognition). ANTLR is used to generate a parser which translates input into a parse tree of skeletons. example input:

\begin{lstlisting}[style=refactor, caption={example input program},label={code1}]
a = Seq (10);
b = Seq (20);
main = Pipe(Farm(a),b);
\end{lstlisting}
The parser creates a tree with root node Pipe skeleton having two stages Farm and Sequential; Farm stage will have one worker process which is type of Sequential. the resulting tree is passed to the refactoring process which is based on  breadth-first search algorithm. the input tree is expanded into a forest of trees in the refactoring process. The tree expansion is done by implementing rewriting rules at level of the skeletons; a visitor based rewriter visits each skeleton node of a tree  and creates a new tree by applying rewriting rules. 

here are the basic rewriting rules:

\begin{itemize}
\item $\Delta \xLongleftrightarrow[\text{Farm\_Intro}]{\text{Farm\_Elim}} farm (\Delta)$\\
\item $Comp(\Delta_1, \Delta_2 )\xLongleftrightarrow[\text{Pipe\_Intro}]{\text{Pipe\_Elim}} Pipe (\Delta_1,\Delta_2)$\\
\item $Map(\Delta) \xLongrightarrow[\text{Map\_Elim}]{\text{}}  (\Delta)$\\
\item $Comp(Comp(\Delta_1, \Delta_2 ),\Delta_3)\xLongleftrightarrow[\text{Comp\_Assoc}]{\text{}} Comp (\Delta_1,Comp(\Delta_2,\Delta_3))$\\
\item $Pipe(Pipe(\Delta_1, \Delta_2 ),\Delta_3)\xLongleftrightarrow[\text{Pipe\_Assoc}]{\text{}} Pipe (\Delta_1,Pipe(\Delta_2,\Delta_3))$\\
\item $Map(Pipe(\Delta_1, \Delta_2 ))\xLongleftrightarrow[\text{Pipe\_of\_map}]{\text{Map\_of\_Pipe}} Pipe (Map(\Delta_1),Map(\Delta_2))$\\
\item $Map(Comp(\Delta_1, \Delta_2 ))\xLongleftrightarrow[\text{Comp\_of\_map}]{\text{Map\_of\_Pipe}} Comp (Map(\Delta_1),Map(\Delta_2))$\\
\end{itemize}


\section{refactoring algorithm}
The parser generates a tree structure with only a single node of type a tree which has skeleton patterns as its child nodes, this tree is fed into a refactoring algorithm which expands it into a tree of trees.The algorithm starting from the input tree performs tree expansion by implementing rewriting rules. the first tree is transformed into different trees and these trees are inserted as child nodes.the algorithm is based on breadth-first search and on the tree expansion process newly created trees are inserted into the queue . the algorithm is based on breadth-first search at the tree level and visitor pattern at the node level, which means trees are refactored in their insertion order and the refactoring process is done using the visitor pattern at nodes level. 
The visitor visits each nodes of a tree and generates new trees replacing the the visited node with it's alternate rewriting options. These new trees are inserted into queue of the algorithm and are processed in their insertion order. This process continues until the queue is empty and the new trees has height maxHeight (a tree can be inserted in queue only if it has height less than maxHeight). The tree is represented as adjacency list meaning a node can have n adjacent nodes which are it's alternative representations. The algorithm tries to explore all the possible options to represent a pattern tree in different combinations of patterns with out considering the performance metrics. 

\begin{lstlisting}[caption={skeleton tree}, label={tree1}]
	Skeleton {
		Skeleton root;
		List<Skeleton> children;
		List<Skeleton> reWritngOptions;
		ReWringRule rule;
	}
	Edge{
		Skeleton from;
		Skeleton to;
		ReWritingRule rule;
	}
\end{lstlisting}
\SetKwRepeat{Do}{do}{while}
\begin{algorithm}[H]
\SetAlgoLined
 \caption {refactoring algorithm}\label{euclid}
  input: program to be parallelized\\
  \KwResult{directed graph of the rewriting options }
  building skeleton tree \texttt{st}\;
  initialization\;
  add \texttt{st to queue}\\
  \While{queue is not empty}{
     st =queue.remove()\;
    patterns = refactor(st)\;
    \Repeat{all patterns are inserted}{
	     If{ pattern not in queue \& pattern.height  $\leq$ maxHeight}{
	        queue.add(pattern)\;  
		}
	}
	\Repeat{all stages are refactored}{
		 patterns = refactor (stage)\;
	     If{ pattern not in queue \& pattern.height $\leq$ maxHeight}{
	        queue.add(pattern)\;
	     }      
	}  
  }

\end{algorithm}
line 1: input, the algorithm accepts input in format of  Listing \ref{code1}.\\
line 2: building tree; the input code is parsed and a new parse tree is constructed .the parser generated by ANTLR parse and construct a tree from the input code.\\
line3: initialization; initlialize queue for the breadth-first search, directed graph to hold the trees generated by the expansion process\\
line 4: start breadth-first search\\
line 7-9: refactoring; this is implemented by using visitor pattern which visits every node of the tree staring from the root and each visit operation creates a new tree which in turn will be added into the queue for further refactoring. since this process creates infinite number of trees i have added a condition to stop the process. for a tree to be refactored it should have a height less than maxHeight.
whenever a new alrernative rewriting option is constructed the algoithm will add it to the graph if it is not already present and it creates an edge from the original skeleton tree to the new one labeling it with the rewring rule used to generate it. if the tree already exists it will just create a new edge between the original tree and the the existing tree object with the rule. \\
line 10-14 is similar to above process except it works on the child nodes of the tree.

\section{Non functional parameters}
in the refactoring procedure the algorithm considers that there are enough number of resources to realize all the tree of patterns so the performance metrics are ideal cases. optimization instead uses the available resources and tries to allocate them in a way that will result a better performance and this resource scheduling process is a complex task. IBM ILOG CP Optimizer is used to tackle this problem. ILOG CP Optimizer is a constraint programming based tool that enables to model and solve scheduling problems. 
the model is comprised of an objective function and list of constraints . in this case the constraints are number of available resources and service time which means the number of resources allocated for each tree node and also the commutative resources assigned to them can not exceed the number of available resources. regarding the parallelism degree , it can not be more than the ideal one. thus the optimal parallelism is determined considering such constraints. the objective function is to minimize the service time , hence the solver gives the optimal parallelism degree that will result a minimum service time.
Here is how  parallelism degree and service times are computed for each kind of skeleton:
\\
	let \texttt{ Tscatter 	T\textsubscript{s}, 					Tcollector T\textsubscript{c} ,Temitter T\textsubscript{e}, Tgather T\textsubscript{g}=1\\
	$T_{\Delta}$ is service time of the stage or worker skeleton\\
	Sequential Skeleton:	n = 1; Ts = ts\\
	Farm Skeleton:	the ideal parallelism degree is computed by $\frac{T\textsubscript{e}}{T_{\Delta}}$ and the ideal service time is calculated using the formula:  {Max($T_e,T_c,\frac{T_\Delta}{n})$}\\
	 Pipeline: {$T_s = Max(T_{si}) \forall i \in pipe stages$} \\
     Map Skeleton:  n = $\sqrt{\frac{T_{\Delta}}{max(T_s, T_g)}}$}\\	
	 
However these formulas are used only to compute the ideal cases; whereas the optimal case is computed using the ILOG CP solver. 
\end{document}
